
### 静态方法和非静态方法

1. 静态方法和非静态方法，他们都是在第一次加载后就常驻内存，所以方法本身在内存里，没有什么区别
2. 在内存中的区别是，非静态方法在创建实例对象时，因为属性的值对于每个对象都各不相同，因此在new一个实例时，会把这个实例属性在GC Heap里拷贝一份，同时这个new出来的对象放在堆栈上，堆栈指针指向了刚才拷贝的那一份实例的内存地址上。而静态方法则不需要，因为静态方法里面的静态


为什么要有非静态方法？

 

早期的结构化编程，几乎所有的方法都是“静态方法”，引入实例化方法概念是面向对象概念出现以后的事情了，区分静态方法和实例化方法不能单单从性能上去理解，创建c++,java,c#这样面向对象语言的大师引入实例化方法一定不是要解决什么性能、内存的问题，而是为了让开发更加模式化、面向对象化。这样说的话，静态方法和实例化方式的区分是为了解决模式的问题。

接下来继续思考，如果我们全部用静态方法，不用非静态方法，不是一样能实现功能吗？是的，没错，但是你的代码是基于对象，而不是面向对象的，因为面向对象的继承和多态，都是非静态方法。

第二个原因是为什么不建议都用静态方法，我们如果多线程的情况下，如果静态方法使用了一个静态字段，这个静态字段可以会被多个线程修改，因此说如果在静态方法里使用了静态变量，这就会有线程安全问题，当然了，就算不是多线程，因为静态字段只有一份，同样会有被其他地方修改的问题。

 

从这三点我们得出的结论如下：

 

一、 什么时候用静态方法，什么时候使用非静态方法？

 

既然静态方法和实例化方式的区分是为了解决模式的问题，如果我们考虑不需要继承和多态的时候，就可以使用静态方法，但就算不考虑继承和多态，就一概使用静态方法也不是好的编程思想。

从另一个角度考虑，如果一个方法和他所在类的实例对象无关，那么它就应该是静态的，否则就应该是非静态。因此像工具类，一般都是静态的。

 

二、 为什么使用单例模式而不用静态方法？

 从面相对象的角度讲：

虽然都能实现目的，但是他们一个是基于对象，一个是面向对象的，就像我们不面相对象也能解决问题一样，面相对象的代码提供一个更好的编程思想。

如果一个方法和他所在类的实例对象无关，那么它就应该是静态的，反之他就应该是非静态的。如果我们确实应该使用非静态的方法，但是在创建类时又确实只需要维护一份实例时，就需要用单例模式了。

比如说我们在系统运行时候，就需要加载一些配置和属性，这些配置和属性是一定存在了，又是公共的，同时需要在整个生命周期中都存在，所以只需要一份就行，这个时候如果需要我再需要的时候new一个，再给他分配值，显然是浪费内存并且再赋值没什么意义，所以这个时候我们就需要单例模式或静态方法去维持一份且仅这一份拷贝，但此时这些配置和属性又是通过面向对象的编码方式得到的，我们就应该使用单例模式，或者不是面向对象的，但他本身的属性应该是面对对象的，我们使用静态方法虽然能同样解决问题，但是最好的解决方案也应该是使用单例模式。

从功能上讲：单例模式可以控制单例数量；可以进行有意义的派生；对实例的创建有更自由的控制

我们在工程中有时需要维护一份信息，比如系统运行时加载的一些配置属性，这些配置属性必须在应用整个生命周期中一直存在，而且是公共的，所以只需要一份就可以了。这时候我们就会考虑使用单例或者静态方法去维护这一份数据，但此时这一份数据又是通过面向对象的方式获取的我们就会使用单例。

        首先静态方法是基于类的，单例是基于对象的。如果解决模式是基于对象的就是用单例，否则使用静态方法。比如需要继承类，实现接口，需要延迟初始化，需要重写父类等要使用单例，第二，静态方法是面向过程的，单例是面向对象的。第三，静态属性变量不会被GC清除，所以单例的对象不会被GC清除，静态方法中产生的对象会随着静态方法执行完毕而被释放。


从时空角度分析问题，空间上模块的划分，时间上生命周期的管理。生命周期：进程生命周期（伴随着程序的启动和退出）、请求生命周期（一次请求的开始和返回）、功能生命周期（一个功能的进入和退出）。一个框架最简单的就是实现这个神功周期。（库和框架的区别就在这里，使用库来实现自己的功能逻辑，框架则负责接管自己的功能逻辑。也就是业务功能 决定 类库的生命周期，框架决定了业务功能的生命周期这种。)


1. 习惯用法是不需要依赖于其它类或资源时，用静态方法，这时就是一个面向过程的函数而已；如果需要依赖其它类的实例，或者需要某些资源时，用单例。
2. 需要继承、重载、多态、设计模式（面相接口编程）、依赖设计好的框架时，使用单例模式。通过继承框架类和实现框架的接口能够快速接入框架提供的功能。
3. 需要方法库是，使用静态方法。（库和框架的区别就在这里，使用库来实现自己的功能逻辑，框架则负责接管自己的功能逻辑。也就是业务功能 决定 类库的生命周期，框架决定了业务功能的生命周期这种。)
3. 