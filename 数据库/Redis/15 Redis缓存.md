

## 1 缓存使用

### 缓存预热

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

解决方法：
1、直接写个缓存刷新页面，上线时手工操作下
2、数据量不大，可以在项目启动的时候自动进行加载
3、定时刷新缓存

 

### 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级

 
## 2 Redis作为缓存可能会出现的问题


### 缓存雪崩

问题：当我们的缓存失效或者redis挂了，那么这个时候的请求都会直接走数据库，就会给数据库造成极大的压力，导致数据库也挂了

解决：

1. 对缓存设置不同的过期时间，这样就不会导致缓存同时失效
2. 建立redis集群，保证服务的可靠性

### 缓存穿透

问题：当有大量用户不走我们设置的键值，就会直接走数据库，就会给数据库造成极大的压力，导致数据库也挂了

解决：

1. 参数过滤和提醒，引导用户走我们的设置的键值
2. 对不合法的参数进行空对象缓存，并设置较短的过期时间

### 缓存与数据库读写一致

问题：如果一直是读的话，是没问题的，但是更新操作会导致数据库已经更新了，缓存还是旧的数据

解决：

并发下解决数据库与缓存不一致的思路：将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。

- 先删除缓存，再更新数据库。在高并发下表现不如意，在原子性被破坏时表现优异

- 先更新数据库，再删除缓存(Cache Aside Pattern设计模式)。在高并发下表现优异，在原子性被破坏时表现不如意


