# 反转链表


## 1 从尾到头打印链表内容

### 问题描述

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

### 问题分类
* 线性数据结构
* 枚举法
* 排序问题

### 问题分析

## 1.1 从尾到头打印链表内容——辅助栈

### 策略选择

* 数据结构：链表、栈、数组
* 算法思想：枚举法
* 可以利用栈的先进后出特性。
### 算法设计


1. 入栈： 遍历链表，将各节点值 push 入栈。（Python​ 使用 append() 方法，​Java​借助 LinkedList 的addLast()方法）。
2. 出栈： 将各节点值 pop 出栈，存储于数组并返回。（Python​ 直接返回 stack 的倒序列表，Java ​新建一个数组，通过 popLast() 方法将各元素存入数组，实现倒序输出）。
### 算法分析
* 时间复杂度O(n)
* 空间复杂度O(n)

### 算法实现

```
    vector<int> reversePrint1(ListNode* head) {
        stack<int> s;
        vector<int> v;
        ListNode * temp=head;
        while(temp){
            s.push(temp->val);
            temp=temp->next;
        }
        while(!s.empty()){
            v.push_back(s.top());
            s.pop();
        }
        return v;
    }
```

## 1.2 从尾到头打印链表内容——递归法

### 策略选择

* 数据结构：链表
* 算法思想：枚举法
* 利用递归后续遍历的特性（子节点在父节点之前除了)

### 算法设计

1. 递推阶段： 每次传入 head.next ，以 head == None（即走过链表尾部节点）为递归终止条件，此时返回空列表 [] 。
2. 回溯阶段： 利用 Python 语言特性，递归回溯时每次返回 当前 list + 当前节点值 [head.val] ，即可实现节点的倒序输出。

### 算法分析

* 时间复杂度O(n)
* 空闲复杂度O(n)

### 算法实现

```
    vector<int> reversePrint(ListNode* head) {
        vector<int> vec;
        rp(head,vec);
        return vec;
    }
    void rp(ListNode* head,vector<int>&vec) {
        if(head==nullptr)return ;
        rp(head->next,vec);
        vec.push_back(head->val);
        return ;
    }
```

