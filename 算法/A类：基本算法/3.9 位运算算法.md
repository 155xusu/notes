> 主要是利用位运算解决一些巧妙的问题。
& ^ ~ |

* n & (n - 1) 会把n中的最后一个1变成0
* 相同的数 ^抑或运算等于零。不同的数^抑或运算等于1

向下整除 n // 2n//2 等价于 右移一位 n >> 1n>>1 ；
取余数 n \% 2n%2 等价于 判断二进制最右一位值 n \& 1n&1 


### 屏蔽计算，作为递归的终止条件

### 快速幂

```
double myPow(double x, int n) {
    //使用二进制方法，将幂转换成二进制。二进制每个位的权重就是可以递推计算，与二分法效果相同。
    long long N=n;
    if(N<0){
        x=1/x;
        N=-N;
    }
    double result=1;
    double temp=x;
    while(N!=0){
        if( N & 1)result=result*temp;
        temp *=temp;
        N= N>>1;
    }
    return result;
```

### 快速乘法

```
int quickMulti(int A, int B) {
    int ans = 0;
    while(B) {
        if (B & 1) ans += A;
        A <<= 1;
        B >>= 1
    }
    return ans;
}
```