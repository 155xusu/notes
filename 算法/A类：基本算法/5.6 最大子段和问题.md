## 1 连续子数组最大和

### 问题描述

* 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。

### 算法设计

* 状态定义： 设动态规划列表 dpdp ，dp[i]dp[i] 代表以元素 nums[i]nums[i] 为结尾的连续子数组最大和。
  * 为何定义最大和 dp[i]dp[i] 中必须包含元素 nums[i]nums[i] ：保证 dp[i]dp[i] 递推到 dp[i+1]dp[i+1] 的正确性；如果不包含 nums[i]nums[i] ，递推时则不满足题目的 连续子数组 要求。
* 转移方程： 若 dp[i-1] \leq 0dp[i−1]≤0 ，说明 dp[i - 1]dp[i−1] 对 dp[i]dp[i] 产生负贡献，即 dp[i-1] + nums[i]dp[i−1]+nums[i] 还不如 nums[i]nums[i] 本身大。   
  * 当 dp[i - 1] > 0dp[i−1]>0 时：执行 dp[i] = dp[i-1] + nums[i]dp[i]=dp[i−1]+nums[i] 
  * 当 dp[i - 1] \leq 0dp[i−1]≤0 时：执行 dp[i] = nums[i]dp[i]=nums[i] ；
* 初始状态： dp[0] = nums[0]dp[0]=nums[0]，即以 nums[0]nums[0] 结尾的连续子数组最大和为 nums[0]nums[0] 。
* 返回值： 返回 dpdp 列表中的最大值，代表全局最大值。

![](image/2021-03-29-09-50-50.png)

### 算法分析

* 时间复杂度 O(N)O(N) ： 线性遍历数组 numsnums 即可获得结果，使用 O(N)O(N) 时间。
* 空间复杂度 O(1)O(1) ： 使用常数大小的额外空间。

### 算法实现

```C++
    int maxSubArray(vector<int>& nums) {
        //动态规划有很多不同的方向。例如，这里把动态变化定位不断增加的连续数组的长度。
        // 当连续数组的长度为1,2,3,4,5时，会利用之前计算的结果。求解。但是这很暴力。
        // 相当于求出了当前的所有最长子数组的解。把问题的规模缩小。
        // nums的长度。动态变化。

        // 失败的动态规划，实际上是暴力求解。
        // vector<vector<int>> vec;
        // int max=-999999;
        // vec.push_back(vector<int>());
        // for(int i=0;i<nums.size();i++){
        //     vec[0].push_back(nums[i]);
        //     if(nums[i]>max){
        //         max=nums[i];
        //     }
        // }
        // for(int i=1;i<nums.size();i++){
        //     vec.push_back(vector<int>());
        //     for(int j=0;j<nums.size()-i;j++){
        //         vec[i].push_back(vec[i-1][j]+vec[0][j+i]);
        //         if(vec[i][j]>max){
        //             max=vec[i][j];
        //         }
        //     }
        // }

        // 正常的动态规划
        int max=nums[0];
        vector<int> vec;
        vec.push_back(nums[0]);
        for(int i=1;i<nums.size();i++){
            int temp =nums[i]+vec[i-1];
            if(temp > nums[i]){
                vec.push_back(temp);
            }
            else{
                vec.push_back(nums[i]);
            }
            if(vec[i]>max){
                max=vec[i];
            }
        }
        return max;
    }
```