# 分治法

## 0 分治法概述
### 基本思想

* 求解问题算法的复杂性一般都与问题规模相关，问题规模越小越容易处理。
* 分治法的基本思想是，将一个难以直接解决的大问题，分解为**规模较小**的**相同类型**的子问题，直至这些子问题容易直接求解，并且可以利用这些子问题的解求出原问题的解。各个击破，分而治之。
* 分治法产生的子问题一般是原问题的较小模式，这就为使用递归技术提供了方便。**递归是分治法中最常用的技术**。

![](image/分治法原理.png)


### 分治法解决问题的先决条件
* 该问题的**规模缩小到一定的程度就可以容易地解决**；
* 该问题可以分解为若干个规模较小的相同问题，即该问题具有**最优子结构性质；**
* 利用该问题分解出的**子问题的解可以合并为该问题的解**；
* 该问题所分解出的**各个子问题是相互独立**的，即子问题之间不包含公共的子问题。

### 分治法的步骤
一般来说，分治法的求解过程由以下三个阶段组成：
1. 划分：既然是分治，当然需要把规模为n的原问题划分为k个规模较小的子问题，并尽量使这k个子问题的规模大致相同。
2. 求解子问题：各子问题的解法与原问题的解法通常是相同的，可以用递归的方法求解各个子问题，有时递归处理也可以用循环来实现。
3. 合并：把各个子问题的解合并起来，合并的代价因情况不同有很大差异，分治算法的有效性很大程度上依赖于合并的实现。

在用分治法设计算法时，最好使子问题的规模大致相同。即将一个问题分成大小相等的k个子问题的处理方法是行之有效的。这种使子问题规模大致相等的做法是出自一种平衡(balancing)子问题的思想，它几乎总是比子问题规模不等的做法要好。

```
divide-and-conquer(P){
    if ( | P | <= n0) adhoc(P);   //解决小规模的问题
    divide P into smaller subinstances P1,P2,...,Pk；//分解问题
    for (i=1; i<=k; i++)
        yi=divide-and-conquer(Pi);  //递归的解各子问题
    return merge(y1,...,yk);  //将各子问题的解合并为原问题的解
  }

```
### 分治法的复杂性

即递归法的时间复杂性。递归求解各个子问题。递归是实现分治算法的手段。

可以通过过计算递归法的时间复杂度，计算分治法的时间复杂度。


## 0 递归法概述

### 基本思想
* 直接或间接的调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。

### 线性收缩递归算法
* 递推关系式

$$
T(n)=\begin{cases}  
    o(1) & n=1 \\
    \sum_{i=1}^k a_iT(n-i)+f(n) & n>1
\end{cases} 
$$

* 求解递推关系式
$$
T(n)=a^{n-1}T(1)+\sum_{i=2}^na^{n-i}f(i)
$$
* 关系式说明

![](image/递归算法-线性收缩说明.png)
### 等比收缩递归算法

* 递推关系式
$$
T(n)=\begin{cases}
    O(1)&n=1 \\
    aT(\frac{n}{b})+f(n) & n>1
\end{cases}
$$
* 求解递推关系式
$$
T(n)=n^{\log_ba} +\sum_{i=2}^{\log_bn-1}a^jf(n/b^j)
$$
* 关系式说明

$$
T(n)=O(n^{\log_ba})+O(f(n))\log_bn
$$
* 其真正的时间复杂度，由前后两部分决定。可以通过计算，得到较大部分的时间复杂度，为整体的时间复杂度。

* 当f(n)为常数时
$$
T(n)=\begin{cases}
    O(n^{\log_ba}) & a\not = 1\\
    O(\log n) & a=1
\end{cases}
$$

* 当f(n)=cn时

$$
T(n)=\begin{cases}
    O(n)&a<b\\
    O(n\log n)& a=b\\
    O(n^{log_b^a})&a>b
\end{cases}
$$

### 直接递归和简介递归
* 直接递归，是指函数自己调用自己的情况。
* 间接递归，是指调用其他函数时，在其他函数中又调用了自己的情况。
### 头递归和尾递归

* 头递归：递归发生在函数的其他处理代码之前（或理解为，递归发生在函数的头部或顶部）
  * 需要使用后续递归后的记过，参与本层的计算，然后返回给上一层。这时，需要在下层的递归完成后，才能计算。如归并计算，需要下一层拍好顺序，这一次才会执行归并操作。
* 尾递归：递归发生在函数其他处理代码的后面（或理解为，递归发生在函数的尾部）
  * 本层内的计算是为了确定递归过程中的条件。且下一层返回的结果，能够作为本层的结果返回。本层不知道改成的结果，结果取决于最底层。如搜索树的最大深度，只有递归到叶节点才知道最大深度是多少。
* 中间部分递归：递归发生在函数体的中间部分。
  * 头递归和尾递归只是描述递归发生的相对顺序。实际上在递归过程中，递归可以发生在任何位置。递归前的代码负责处理本层的与下一层无关的内容。递归后的代码负责利用下一层的返回值或其他变量处理内容。

### 递归的终止条件
* 终止递归：终止递归有两种思路。
  1. 本层不满足条件。终止递归。当进入本层后，首先判断递归是否终止。
  2. 下一层不满足条件。终止递归。当要进行递归前，判断是否还需要进行递归。前提是直到下一层是否满足条件的计算。
* 本层判断更符合递归的思想，且在实现过程中，一般也相对简单。

### 递归的实现

1. 设计递归的参数。首先确定每一次递归，上一层需要提供给下一层的内容。
2. 设计递归的返回值。设计递归需要返回的内容，即提供给上一层的内容。
3. 设计递归的开始。设计如何开始递归。怎样调用递归。有了上一层的参数和返回值的需求，相当于提供了一个函数的接口。那么就可以调用递归函数，开始递归了。
4. 设计递归的终止条件。一旦开始递归，就要设计递归的终止条件。
5. 递归前的数据处理。在递归前需要处理的数据，提供给递归函数。
6. 递归后的数据处理。在递归后需要处理的数据。提供给上层函数和最终结果。



### 递归算法理解

* 递归算法本质上是一种自顶向下的思考模式。即数学上所说的归纳法。有结果一步一步归纳，得到验证其条件的正确性。问题规模逐渐变小。
* 非递归算法的本质是一种自底向上的思考模式。即数学上所说的推导法。将一些零碎的部分逐渐求解，渐渐得到最终的结果。问题逐渐组装成目标问题。

* 在使用递归的时候，应该从顶层考虑怎么分割。在使用非递归算法的时候，应该考虑怎样从顶层进行组合。

###

## 0 减治法概述

### 基本思想

一个问题给定实例的解和同样问题较小实例的解之间的关系。一旦建立了这样一种关系，我们既可以递归地，也可以非递归地地来运用减治技术。

### 分类

* 减去一个常量 (decrease by a constant)
* 减去一个常数因子(decrease by a constant factor)
* 减去的规模是可变的(variable size decrease)

### 算法原理
* 在减常量变种中，每次算法迭代总是从实例规模中减去一个规模相同的常量。经常地，这个常量等于一。函数f(n) = an可以用一递归定义来计算
```
f(n) =　f (n-1) *a		如果n > 1
	 =	a			如果n = 1
```


* 减常因子技术意味着在算法的每次迭代中，总是从实例的规模中减去一个相同的常数因子。在多数应用中，这样的常数因子等于二。例如：计算an的值是规模为n的实例：an = (an/2)2。O(log n);

* 在减治法的减可变规模变种中，算法在每次迭代时，规模减小的模式都是不同的。例如：欧几里得算法：gcd (m,n) = gcd (n, m mod n) 

### 算法效率

与蛮力法相同。但是思想不同。


### 与分治法对比

该算法和基于分治思想的算法有所不同:
* 分治法分解成规模相似的类型相同的子问题。
* 减治法直接通过运算将问题的规模减小。问题数量没有增加。


## 0 变治法概述

### 基本思想

1. 变换为同样问题的一个更简单或者更方便 的实例—实例化简(Instance simplification)。
2. 变换为同样实例的不同表现—改变表现(Representation Change).
3. 变换为另一个问题的实例， 这种问题的算法是已知的—问题化简(Problem reduction).

> 根本上是转换问题的思路。

## 1 分治法应用

### 排列问题


### 整数划分问题

### 二分搜索问题√
O(\log n)

* 迭代空间O(1)
* 递归空间O(\log n)
### 大数乘法√
O(n^(log 3))
### 矩阵乘法√

### 快速排序√

### 合并排序√
O(n\log n)
### 线性时间选择√
* 选择最大最小元素-分治或暴力
O(n)
* 选择第k小元素-快排的一半
O(n)
### 最近点对问题√

### 棋盘覆盖问题

## 2 减治法应用

### 拓扑排序

### 生成子集
* 比特串方法
### 假币问题

### 俄式乘法

### 约瑟夫问题

### gcd欧几里得算法

### 插值查找

### 二叉树查找


## 3 变治法应用
### 元素唯一性-预排序算法

### 模式计算-预排序算法
* 问题描述


在给定的数字列表中最经常出现的一个数值称为模式（Mode）。 （例：5，1，5，7，6，5，7，模式是5）

* 暴力法O(n^2)
* 预排序O(n\log n)


### 线性方程组-高斯小区算法

* 问题描述
n个线性方程构成的n 元联立方程组
* 高斯消去O(n^3)

### 霍纳法则

* 问题描述

针对一个给定的x 的多项式p(x) = anxn + an-1xn-1 + … + a1x + a0 求值

* 思想

它不断地把x作为公因子从降次以后的剩余多项式中提取出来：(x) =(…(anx + an-1)x + ..)x + a0 

* 例子

```
p(x) 	= 2x4 - x3 + 3x2  + x - 5
			= x（2x3 - x2 + 3x + 1 ）- 5
			= x（x（2 x2 - x +3）+1）-5
			= x（x（x（2 x-1）+3）+1）-5

```

### lcm 最小公倍数

### AVL树

### 2-3树

### 堆排序

### 二进制幂







