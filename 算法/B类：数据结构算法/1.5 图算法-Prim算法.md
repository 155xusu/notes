# 图算法-Prim算法
> 目录
>* 图算法-Dijkstra算法
>* 图算法-Floyd算法
>* 图算法-Bellman-Ford算法
>* 图算法-Prim算法
>* 图算法-Kruskal算法

> 参考文献
> [https://www.cnblogs.com/ggzhangxiaochao/p/9070873.html](https://www.cnblogs.com/ggzhangxiaochao/p/9070873.html)

## 1 问题分析

* 普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索**最小生成树**。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。
* 主要是**顶点的贪心思想**。

## 2 算法原理

1. 输入：一个加权连通图，其中顶点集合为V，边集合为E；

2. 初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；

3. 重复下列操作，直到Vnew = V：

    * 在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；

    * 将v加入集合Vnew中，将<u, v>边加入集合Enew中；

4. 输出：使用集合Vnew和Enew来描述所得到的最小生成树。


## 3 算法过程

<table class="wikitable" border="1" cellspacing="2" cellpadding="5">
<tbody>
<tr><th>图例</th><th>说明</th><th>不可选</th><th>可选</th><th>已选（V<sub>new</sub>）</th></tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073015154494.png" alt="" width="200" height="168"></p>
</td>
<td>此为原始的加权连通图。每条边一侧的数字代表其权值。</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073015175038.png" alt="" width="200" height="168"></p>
</td>
<td>顶点<strong>D</strong>被任意选为起始点。顶点<strong>A</strong>、<strong>B</strong>、<strong>E</strong>和<strong>F</strong>通过单条边与<strong>D</strong>相连。<strong>A</strong>是距离<strong>D</strong>最近的顶点，因此将<strong>A</strong>及对应边<strong>AD</strong>以高亮表示。</td>
<td>C, G</td>
<td>A, B, E, F</td>
<td>D</td>
</tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016090032.png" alt="" width="200" height="168"></p>
</td>
<td>下一个顶点为距离<strong>D</strong>或<strong>A</strong>最近的顶点。<strong>B</strong>距<strong>D</strong>为9，距<strong>A</strong>为7，<strong>E</strong>为15，<strong>F</strong>为6。因此，<strong>F</strong>距<strong>D</strong>或<strong>A</strong>最近，因此将顶点<strong>F</strong>与相应边<strong>DF</strong>以高亮表示。</td>
<td>C, G</td>
<td>B, E, F</td>
<td>A, D</td>
</tr>
<tr>
<td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016130394.png" alt="" width="200" height="168"></td>
<td>算法继续重复上面的步骤。距离<strong>A</strong>为7的顶点<strong>B</strong>被高亮表示。</td>
<td>C</td>
<td>B, E, G</td>
<td>A, D, F</td>
</tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016143177.png" alt="" width="200" height="168"></p>
</td>
<td>在当前情况下，可以在<strong>C</strong>、<strong>E</strong>与<strong>G</strong>间进行选择。<strong>C</strong>距<strong>B</strong>为8，<strong>E</strong>距<strong>B</strong>为7，<strong>G</strong>距<strong>F</strong>为11。<strong>E</strong>最近，因此将顶点<strong>E</strong>与相应边<strong>BE</strong>高亮表示。</td>
<td>无</td>
<td>C, E, G</td>
<td>A, D, F, B</td>
</tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016154616.png" alt="" width="200" height="168"></p>
</td>
<td>这里，可供选择的顶点只有<strong>C</strong>和<strong>G</strong>。<strong>C</strong>距<strong>E</strong>为5，<strong>G</strong>距<strong>E</strong>为9，故选取<strong>C</strong>，并与边<strong>EC</strong>一同高亮表示。</td>
<td>无</td>
<td>C, G</td>
<td>A, D, F, B, E</td>
</tr>
<tr>
<td>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016114494.png" alt="" width="200" height="168"></p>
</td>
<td>顶点<strong>G</strong>是唯一剩下的顶点，它距<strong>F</strong>为11，距<strong>E</strong>为9，<strong>E</strong>最近，故高亮表示<strong>G</strong>及相应边<strong>EG</strong>。</td>
<td>无</td>
<td>G</td>
<td>A, D, F, B, E, C</td>
</tr>
<tr>
<td>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016100874.png" alt="" width="200" height="168"></p>
</td>
<td>现在，所有顶点均已被选取，图中绿色部分即为连通图的最小生成树。在此例中，最小生成树的权值之和为39。</td>
<td>无</td>
<td>无</td>
<td>A, D, F, B, E, C, G</td>
</tr>
</tbody>
</table>

## 4 算法效率
顶点数V，边数E。时间复杂度：

* 邻接矩阵:$O(V^2)$
* 邻接表:$O(E\log_2V)$


## 5 算法实现

```C++

```