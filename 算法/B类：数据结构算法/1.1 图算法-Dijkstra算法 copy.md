# 图算法-Dijkstra算法

> 目录
>* 图算法-Dijkstra算法
>* 图算法-Floyd算法
>* 图算法-Bellman-Ford算法
>* 图算法-Prim算法
>* 图算法-Kruskal算法



>参考文献
> [https://www.cnblogs.com/msymm/p/9769915.html](https://www.cnblogs.com/msymm/p/9769915.html)


## 1 问题分析
* 最短路径算法。用于**计算一个节点到其他节点的最短路径。**

* Dijkstra算法算是**贪心思想**实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。

## 2 算法原理
* 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 

* 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 

* 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是"起点s到该顶点的路径"。
* 然后，从U中找出路径最短的顶点，并将其加入到S中；
* 接着，更新U中的顶点和顶点对应的路径。 
* 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 ... 重复该操作，直到遍历完所有顶点。

## 3 算法步骤

### 基本步骤
1. 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为"起点s到该顶点的距离"[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 

2. 从U中选出"距离最短的顶点k"，并将顶点k加入到S中；同时，从U中移除顶点k。 

3. 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 

4. 重复步骤(2)和(3)，直到遍历完所有顶点。 

### 图解过程
![](image/Dijkstra算法.jpg)

### 详细说明

初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！ 

* 第1步：将顶点D加入到S中。 
    此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。 

* 第2步：将顶点C加入到S中。 
    上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 
    此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。 

* 第3步：将顶点E加入到S中。 
    上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 
    此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。 

* 第4步：将顶点F加入到S中。 
    此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。

* 第5步：将顶点G加入到S中。 
    此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。

* 第6步：将顶点B加入到S中。 
    此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。

* 第7步：将顶点A加入到S中。 
    此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。

此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。

## 4 算法效率

时间复杂度$O(n^2)$
## 5 算法实现

```
#include<iostream>
#include<sstream>
using namespace std;
const int Max=100;
string Int_to_String(int n)//int转换string 
{
ostringstream stream;
stream<<n; //n为int类型
return stream.str();
}
class MGraph{
    public:
        MGraph(){

        }
        MGraph(int n,int e);
        ~MGraph(){

        }
    public:
    int vertex[Max];
    int arc[Max][Max];
    int vertexNum,arcNum;
};
MGraph::MGraph(int n,int e){
    int i,j;
    vertexNum=n;
    arcNum=e;
    for(int i=0;i<vertexNum;i++)
        vertex[i]=i;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            arc[i][j]=10000;
    cout<<"请输入图中各边的情况："<<endl;
    for(int k=0;k<e;k++){
        cin>>i>>j;
        cin>>arc[i][j];
    }
}
void Dijkstra(MGraph G,int v){
    int dist[Max],s[Max];
    string path[Max]; 
    for(int i=0;i<G.vertexNum;i++)
    {
        dist[i]=G.arc[v][i];
        if(dist[i]!=10000)
            path[i]=Int_to_String(G.vertex[v])+"->"+Int_to_String(G.vertex[i]);
        else
            path[i]="";
    }
    s[0]=v;
    dist[v]=0;
    int num=1;
    for(int i=0;i<G.vertexNum;i++)
    {
        int t=10000,k;
        for(int j=0;j<G.vertexNum;j++)
        {
            if(dist[j]<t&&dist[j]!=0)
            {
                t=dist[j];
                k=j;
            }
        }
        cout<<"终点为："<<k<<"  最短路径长度为："<<dist[k]<<"  过程："<<path[k]<<endl;
        s[num++]=k;
        for(int j=0;j<G.vertexNum;j++){
            if(dist[j]!=0&&dist[j]>(dist[k]+G.arc[k][j])){
                dist[j]=dist[k]+G.arc[k][j];
                path[j]=path[k]+"->"+Int_to_String(j);
            }
        }
        dist[k]=0;
        if(num==G.vertexNum)
            break;
    }
    cout<<"找到终点的顺序为："<<endl;
    for(int i=1;i<num;i++)
        cout<<s[i]<<" "; 
    cout<<endl;
}
int main(){
   int n,e,v;
   cout<<"输入起点下标："<<endl; 
   cin>>v;
   cout<<"输入图的顶点数和边数："<<endl;
   cin>>n>>e;
   MGraph G(n,e);
   Dijkstra(G,v);
   return 0;
}
```