## 1 include

### 基本使用
```
include<iostream>
include"a.cpp"
```

### 原理

* #include是C++预处理器的一部分。预处理器处理程序的源代码，是在编译器之前运行。#include只接受一个参数：头文件名。预处理器用指定的头文件的内容替代每个include。
* include的作用是从源代码上的复制粘贴。不会进行逻辑处理，而是直接插入引用的部分。
* 一个程序的头文件.h不是为了给自己用的，而是为了给其他程序用的。所以，在给别人使用的.h中声明extern int的全局变量很重要。

## 2 extern
### 基本使用
* 声明一个变量
* 不带定义，不申请空间。

```
extern int i;
```

### 原理

* 语句：extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，也并未为a分配空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出错。

* 通常来说，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字extern声明。例如，如果模块B要引用模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但并不会报错；它会在链接阶段从模块A编译生成的目标代码中找到该函数。
* 函数的声明extern关键词可有可无，因为函数本身不加修饰的话就是extern。全局变量在外部使用的时候，extern关键字是必须的。局部变量的声明不能有extern，且局部变量在运行时才在堆栈部分分配内存。
* 全局变量是在函数外部声明的变量。函数名本身在函数外部，也是全局的。
* 修饰声明全局变量或函数，其声明的变量和函数可以在其它模块（文件）中使用，注意，这只是一个声明而不是定义，具体的定义要在具体的模块中完成。


## 3 const

### 基本使用

```
const int bufersize = 512
```

### 原理

* 它的值不能被改变，不能进行赋值操作，只能进行初始化。
* 默认情况下，const值尽在文件中有效。编译器在编译过程中会把用到该变量的地方都替换成对应的值。

## 4 typedef

### 基本使用


typedef使用最后一个名词作为名字
```
typedef double hello;
typedef double* p;
typedef int h[81];
typedef　struct　tag
{
int　iNum;
long　lLength;
}MyStruct;//定义了结构体；typedef struct tag MyStruct
```
### 原理

* typedef使用最后一个名词作为名字

## 5 using

### 基本使用

```
using SI = Sales_item;
```

### 原理

* 类型别名和类型等价


## 6 auto
### 基本使用

```
auto item = val1 +val2
```
### 原理

* 编译器自动分析类型
## 7 decltype
### 基本使用

```
decltype(f()) sum =x;
```

### 原理
* 根据表达式推断类型，而不会计算表达式。类型推断。

> 略过的constexp,


## 8 volatile

### 基本使用

```
volatile data-definition;
```

### 原理
关键字 volatile 是与 const 绝对对立的。它指示一个变量也许会被某种方式修改，这种方式按照正常程序流程分析是无法预知的（例如，一个变量也许会被一个中断服务程序所修改）。这个关键字使用下列语法定义：

变量如果加了 volatile 修饰，则会从内存重新装载内容，而不是直接从寄存器拷贝内容。 

volatile应用比较多的场合，在中断服务程序和cpu相关寄存器的定义。

## 9 extern "C"

### 使用

```C
//moduleA头文件
#ifndef __MODULE_A_H //对于模块A来说，这个宏是为了防止头文件的重复引用
#define __MODULE_A_H
int fun(int, int);
#endif
 
//moduleA实现文件moduleA.C //模块A的实现部分并没有改变
#include"moduleA"
int fun(int a, int b)
{
return a+b;
}
 
//moduleB头文件
#idndef __MODULE_B_H //很明显这一部分也是为了防止重复引用
#define __MODULE_B_H
#ifdef __cplusplus //而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件， 
extern "C"{ //因为cpp文件默认定义了该宏),则采用C语言方式进行编译
#include"moduleA.h"
#endif
… //其他代码
 
#ifdef __cplusplus
}
#endif
#endif
 
//moduleB实现文件 moduleB.cpp //B模块的实现也没有改变，只是头文件的设计变化了
#include"moduleB.h"
int main()
{
　　cout<<fun(2,3)<<endl;
}
```
### 原理

* extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。


这个功能主要用在下面的情况：

1. C++代码调用C语言代码
2. 在C++的头文件中使用
3. 在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到


## 10 override关键字

* 子类重写父类函数的时候，使用override关键字标识。可以省略。


## 11 final关键字

* final类不能被继承。
* final函数不能被子类重写或重定义。


## 12 static
### 1 全局static

* 在函数体、块作用域之外声明的变量与函数是全局的。
* 对于全局函数和全局变量，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。


### 2 代码块 static

* 对于代码块内部的变量。static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。
* 对于代码块内的函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用

### 3 类成员 static

1. **类的静态成员**：在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

2. **类的静态函数**：静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

3. 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);