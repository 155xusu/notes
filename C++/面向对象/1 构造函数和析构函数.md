# 拷贝控制

> 目录
> * 拷贝、赋值与销毁
> * 拷贝控制和资源管理
> * 交换操作
> * 拷贝控制实例
> * 动态内存管理类
> * 对象移动

> 类的特殊函数
> * 初始化——构造函数
> * 拷贝——拷贝构造函数
> * 移动——移动构造函数
> * 赋值——拷贝赋值运算符、移动赋值运算符
> * 销毁——析构函数

## 1 构造函数

> 与类同名的，没有返回值的函数，用来创建、赋值、移动、销毁该类的对象。
## 1.1 合成构造函数

编译器自动生成的一系列构造函数。包括以下几种
* 合成默认构造函数
  * 当用户定义了任意类型的构造函数，编译器不再自动生成合成默认构造函数
* 合成拷贝构造函数
  * 即是用户定义了其他类型的构造函数，编译器还会自动生成合成拷贝构造函数。
  * 编译器自动生成的拷贝构造函数。从给定的对象中依次将每个非static成员拷贝到正在创建的对象当中。
* 合成析构函数
  * 系统自动生成的析构函数。

## 1.2 默认构造函数

无参构造函数。

## 1.3 拷贝构造函数

唯一参数是当前类类型，或者当前类型的const引用。

### 示例
```
class Foo{
    Foo();
    Foo(const Foo&)//拷贝构造函数
}
```

### 赋值初始化（拷贝构造函数）

> 赋值初始化的时候会自动调用拷贝构造函数。

```
string nies = string("efji");
```
* 当我门使用 赋值= 运算符时，发生赋值初始化，执行拷贝构造函数。
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为费引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

### 赋值运算符（拷贝运算符）

> 普通赋值的时候，会调用重载的赋值运算符。

* 编译器会自动生成合成拷贝赋值运算符
* 需要重载赋值运算符。

## 1.4 移动构造函数


## 1.5 委托构造函数

* 使用已有的构造函数初始化。


## 2 析构函数

### 定义析构函数
* 析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。
* 类的成员函数，由拨浪号接类名构成，没有返回值，不接受参数。不能被重载，一个类只有一个析构函数。

```
class Foo{
    public:
        ~Foo();
}
```
### 原理
* 在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序逆序销毁。
* 智能指针成员在西沟阶段会自动销毁。

### 何时调用
* 变量离开作用域被销毁
* 一个对象被销毁
* 容器被销毁
* 动态对象，使用delete

### 对象析构顺序

1. 派生类本身的析构函数；
2. 对象成员析构函数；
3. 基类析构函数。


## 3 虚函数与构造函数和析构函数

### 构造函数不必是虚函数

1. 对象通过虚函数指针访问虚函数。在执行构造函数之前，虚函数指针没有创建，所以即使声明为虚函数，也不会有多态，所以不必要是虚函数。

### 析构函数必须是虚函数

1. 删除动态运行时的具体对象。
2. 普通对象如果不被继承，析构函数可以不使用虚函数。避免生成虚函数表和虚函数指针，浪费内存空间。