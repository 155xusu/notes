## 1 alloc
alloc是向栈申请内存，因此无需释放。

* 功能：返回一个指向n个连续字符存储单元的指针。利用afree§释放已经分配的存储空间，以便以后使用。

* 函数原型: char *alloc(int n);

## 2 malloc(memeory allocation,动态内存分配)
malloc分配的内存是位于堆中的，并且没有初始化内存的内容，因此基本上malloc之后，调用函数memset来初始化这部分的内存空间。
* **功能** 用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存，且分配的大小就是程序要求的大小。
* 函数原型： void *malloc(unsigned int size)
### 工作机制

* malloc函数的实质体现在，他有一个将可用的内存块连接为一个常常的链表的所谓空闲链表。调用malloc函数是，他沿着连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，他将用户释放的内存块连接到空闲链表上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上，检查各个内存片段，对他们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。

* linux Libc6采用的机制是在free的时候试图整合相邻的碎片，使其合并称为一个较大的free空间。

注意总结：
1. 使用malloc一定要判断返回值是否为NULL。
2. 使用malloc要用memset初始化。


## 3 calloc
calloc则将初始化这部分的内存设置为0。
* 函数原型：void *calloc(unsigned int num,unsigned int size);
* 功能：在内存的动态存储区中分配n个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。num对象个数，size：对象占据的内存字节数，相较于malloc函数，calloc函数会自动将内存初始化为0。而malloc不做初始化，分配到空间中的数据是随机数据。

## 4 realloc
realloc对申请的内存进行大小的调整，申请的内存最终需要通过函数free来释放。
* 函数原型：extern void *realloc(void *mem_address,unsigned int newsize);
* 功能：先判断当前的指针是够有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域(注意L原来指针是自动释放，不需要使用free)，同时返回新分配的内存区域的首地址。


### 注意事项
1. 头文件：#include <stdlib.h> 有些编译器需要 #include <malloc.h>
2. 原先的地址如果放弃使用是会被自动释放的。不要手动的free否则会造成内存泄露。
3. newsize小于原先的大小的时候，可能会造成数据丢失。
4. mem_address一定要是malloc，calloc或realloc申请得到指针。
5. 如果newsize大小为0，那么释放mem_address指向的内存，并返回NULL。这里需要注意的是只对指针本身进行释放，例如对二维指针**a，对a调用realloc时只会释放一维，使用时谨防内存泄漏。
6. 如果没有足够可用的内存用来完成重新分配（扩大原来的内存块或者分配新的内存块），则返回NULL。而原来的内存块保持不变。
7. 传递给realloc的指针可以为空，效果等同于malloc。
