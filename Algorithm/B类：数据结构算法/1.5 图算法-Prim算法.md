# 图算法-Prim算法
> 目录
>* 图算法-Dijkstra算法
>* 图算法-Floyd算法
>* 图算法-Bellman-Ford算法
>* 图算法-Prim算法
>* 图算法-Kruskal算法

> 参考文献
> [https://www.cnblogs.com/ggzhangxiaochao/p/9070873.html](https://www.cnblogs.com/ggzhangxiaochao/p/9070873.html)

## 1 问题分析

普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。

## 2 算法原理

1. 输入：一个加权连通图，其中顶点集合为V，边集合为E；

2. 初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；

3. 重复下列操作，直到Vnew = V：

    * 在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；

    * 将v加入集合Vnew中，将<u, v>边加入集合Enew中；

4. 输出：使用集合Vnew和Enew来描述所得到的最小生成树。


## 3 算法过程

<table class="wikitable" border="1" cellspacing="2" cellpadding="5">
<tbody>
<tr><th>图例</th><th>说明</th><th>不可选</th><th>可选</th><th>已选（V<sub>new</sub>）</th></tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073015154494.png" alt="" width="200" height="168"></p>
</td>
<td>此为原始的加权连通图。每条边一侧的数字代表其权值。</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073015175038.png" alt="" width="200" height="168"></p>
</td>
<td>顶点<strong>D</strong>被任意选为起始点。顶点<strong>A</strong>、<strong>B</strong>、<strong>E</strong>和<strong>F</strong>通过单条边与<strong>D</strong>相连。<strong>A</strong>是距离<strong>D</strong>最近的顶点，因此将<strong>A</strong>及对应边<strong>AD</strong>以高亮表示。</td>
<td>C, G</td>
<td>A, B, E, F</td>
<td>D</td>
</tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016090032.png" alt="" width="200" height="168"></p>
</td>
<td>下一个顶点为距离<strong>D</strong>或<strong>A</strong>最近的顶点。<strong>B</strong>距<strong>D</strong>为9，距<strong>A</strong>为7，<strong>E</strong>为15，<strong>F</strong>为6。因此，<strong>F</strong>距<strong>D</strong>或<strong>A</strong>最近，因此将顶点<strong>F</strong>与相应边<strong>DF</strong>以高亮表示。</td>
<td>C, G</td>
<td>B, E, F</td>
<td>A, D</td>
</tr>
<tr>
<td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016130394.png" alt="" width="200" height="168"></td>
<td>算法继续重复上面的步骤。距离<strong>A</strong>为7的顶点<strong>B</strong>被高亮表示。</td>
<td>C</td>
<td>B, E, G</td>
<td>A, D, F</td>
</tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016143177.png" alt="" width="200" height="168"></p>
</td>
<td>在当前情况下，可以在<strong>C</strong>、<strong>E</strong>与<strong>G</strong>间进行选择。<strong>C</strong>距<strong>B</strong>为8，<strong>E</strong>距<strong>B</strong>为7，<strong>G</strong>距<strong>F</strong>为11。<strong>E</strong>最近，因此将顶点<strong>E</strong>与相应边<strong>BE</strong>高亮表示。</td>
<td>无</td>
<td>C, E, G</td>
<td>A, D, F, B</td>
</tr>
<tr>
<td>&nbsp;
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016154616.png" alt="" width="200" height="168"></p>
</td>
<td>这里，可供选择的顶点只有<strong>C</strong>和<strong>G</strong>。<strong>C</strong>距<strong>E</strong>为5，<strong>G</strong>距<strong>E</strong>为9，故选取<strong>C</strong>，并与边<strong>EC</strong>一同高亮表示。</td>
<td>无</td>
<td>C, G</td>
<td>A, D, F, B, E</td>
</tr>
<tr>
<td>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016114494.png" alt="" width="200" height="168"></p>
</td>
<td>顶点<strong>G</strong>是唯一剩下的顶点，它距<strong>F</strong>为11，距<strong>E</strong>为9，<strong>E</strong>最近，故高亮表示<strong>G</strong>及相应边<strong>EG</strong>。</td>
<td>无</td>
<td>G</td>
<td>A, D, F, B, E, C</td>
</tr>
<tr>
<td>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016100874.png" alt="" width="200" height="168"></p>
</td>
<td>现在，所有顶点均已被选取，图中绿色部分即为连通图的最小生成树。在此例中，最小生成树的权值之和为39。</td>
<td>无</td>
<td>无</td>
<td>A, D, F, B, E, C, G</td>
</tr>
</tbody>
</table>

## 4 算法效率
顶点数V，边数E。时间复杂度：

* 邻接矩阵:$O(V^2)$
* 邻接表:$O(E\log_2V)$


## 5 算法实现

```
#include <stdio.h>
#include <stdlib.h>
#define VertexType int
#define VRType int
#define MAX_VERtEX_NUM 20
#define InfoType char   
#define INFINITY 65535
typedef struct {
    VRType adj;                             //对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。
    InfoType * info;                        //弧额外含有的信息指针
}ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];
typedef struct {
    VertexType vexs[MAX_VERtEX_NUM];        //存储图中顶点数据
    AdjMatrix arcs;                         //二维数组，记录顶点之间的关系
    int vexnum,arcnum;                      //记录图的顶点数和弧（边）数
}MGraph;
//根据顶点本身数据，判断出顶点在二维数组中的位置
int LocateVex(MGraph G,VertexType v){
    int i=0;
    //遍历一维数组，找到变量v
    for (; i<G.vexnum; i++) {
        if (G.vexs[i]==v) {
            return i;
        }
    }
    return -1;
}
//构造无向网
void CreateUDN(MGraph* G){
    scanf("%d,%d",&(G->vexnum),&(G->arcnum));
    for (int i=0; i<G->vexnum; i++) {
        scanf("%d",&(G->vexs[i]));
    }
    for (int i=0; i<G->vexnum; i++) {
        for (int j=0; j<G->vexnum; j++) {
            G->arcs[i][j].adj=INFINITY;
            G->arcs[i][j].info=NULL;
        }
    }
    for (int i=0; i<G->arcnum; i++) {
        int v1,v2,w;
        scanf("%d,%d,%d",&v1,&v2,&w);
        int m=LocateVex(*G, v1);
        int n=LocateVex(*G, v2);
        if (m==-1 ||n==-1) {
            printf("no this vertex\n");
            return;
        }
        G->arcs[n][m].adj=w;
        G->arcs[m][n].adj=w;
    }
}
//辅助数组，用于每次筛选出权值最小的边的邻接点
typedef struct {
    VertexType adjvex;//记录权值最小的边的起始点
    VRType lowcost;//记录该边的权值
}closedge[MAX_VERtEX_NUM];
closedge theclose;//创建一个全局数组，因为每个函数中都会使用到
//在辅助数组中找出权值最小的边的数组下标，就可以间接找到此边的终点顶点。
int minimun(MGraph G,closedge close){
    int min=INFINITY;
    int min_i=-1;
    for (int i=0; i<G.vexnum; i++) {
        //权值为0，说明顶点已经归入最小生成树中；然后每次和min变量进行比较，最后找出最小的。
        if (close[i].lowcost>0 && close[i].lowcost < min) {
            min=close[i].lowcost;
            min_i=i;
        }
    }
    //返回最小权值所在的数组下标
    return min_i;
}
//普里姆算法函数，G为无向网，u为在网中选择的任意顶点作为起始点
void miniSpanTreePrim(MGraph G,VertexType u){
    //找到该起始点在顶点数组中的位置下标
    int k=LocateVex(G, u);
    //首先将与该起始点相关的所有边的信息：边的起始点和权值，存入辅助数组中相应的位置，例如（1，2）边，adjvex为0，lowcost为6，存入theclose[1]中，辅助数组的下标表示该边的顶点2
    for (int i=0; i<G.vexnum; i++) {
        if (i !=k) {
            theclose[i].adjvex=k;
            theclose[i].lowcost=G.arcs[k][i].adj;
        }
    }
    //由于起始点已经归为最小生成树，所以辅助数组对应位置的权值为0，这样，遍历时就不会被选中
    theclose[k].lowcost=0;
    //选择下一个点，并更新辅助数组中的信息
    for (int i=1; i<G.vexnum; i++) {
        //找出权值最小的边所在数组下标
        k=minimun(G, theclose);
        //输出选择的路径
        printf("v%d v%d\n",G.vexs[theclose[k].adjvex],G.vexs[k]);
        //归入最小生成树的顶点的辅助数组中的权值设为0
        theclose[k].lowcost=0;
        //信息辅助数组中存储的信息，由于此时树中新加入了一个顶点，需要判断，由此顶点出发，到达其它各顶点的权值是否比之前记录的权值还要小，如果还小，则更新
        for (int j=0; j<G.vexnum; j++) {
            if (G.arcs[k][j].adj<theclose[j].lowcost) {
                theclose[j].adjvex=k;
                theclose[j].lowcost=G.arcs[k][j].adj;
            }
        }
    }
    printf("\n");
}
int main(){
    MGraph G;
    CreateUDN(&G);
    miniSpanTreePrim(G, 1);
}
```