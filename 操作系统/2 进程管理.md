# 进程管理

## 2 进程管理
1. 进程的基本概念
2. 进程控制
3. 进程同步
4. 进程通信
5. 线程
6. 管程

## 1 进程与线程

### 进程

* 进程是资源分配的基本单位。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

* 下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。

![](image/2021-03-29-22-52-14.png)

### 线程

* 线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。

* QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。
![](image/2021-03-29-22-53-11.png)

### 区别

1. 拥有资源。进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
2. 调度。线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. 系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
4. 通信方面。线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。

## 2 进程状态的切换

![](image/2021-03-29-22-54-26.png)

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

### 应该注意以下内容

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

## 3 进程调度算法

* 不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

### 批处理系统

* 批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

1. 先来先服务 first-come first-serverd（FCFS）

   * 非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

1. 短作业优先 shortest job first（SJF）

   * 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

3. 最短剩余时间优先 shortest remaining time next（SRTN） 

   * 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

### 交互式系统

* 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

1. 时间片轮转

   * 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

   * 时间片轮转算法的效率和时间片的大小有很大关系：
     - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
     - 而如果时间片过长，那么实时性就不能得到保证。
   ![](image/2021-03-29-22-56-33.png)

2. 优先级调度

   * 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

3. 多级反馈队列

   * 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。
   * 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。
   * 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。
   ![](image/2021-03-29-22-57-07.png)

### 实时系统

   * 实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

## 4 进程同步

### 临界区

* 对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```html
// entry section
// critical section;
// exit section
```

### 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

### 3. 信号量

* 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

  -   **down**   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
  -   **up**  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了   **互斥量（Mutex）**  ，0 表示临界区已经加锁，1 表示临界区解锁。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

\<font size=3\>   **使用信号量实现生产者-消费者问题**   \</font\> \</br\>

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

### 4. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```pascal
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
```

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了   **条件变量**   以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

<font size=3>  **使用管程实现生产者-消费者问题**  </font><br>

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

## 经典同步问题

生产者和消费者问题前面已经讨论过了。

### 1. 哲学家进餐问题

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。

```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

```c
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&mutex);
    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}

void eat(int i) {
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

### 2. 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```

以下内容由 [@Bandi Yugandhar](https://github.com/yugandharbandi) 提供。

The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).

```c
int readcount, writecount;                   //(initial value = 0)
semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)

//READER
void reader() {
<ENTRY Section>
 down(&readLock);                 //  reader is trying to enter
 down(&rmutex);                  //   lock to increase readcount
  readcount++;                 
  if (readcount == 1)          
   down(&resource);              //if you are the first reader then lock  the resource
 up(&rmutex);                  //release  for other readers
 up(&readLock);                 //Done with trying to access the resource

<CRITICAL Section>
//reading is performed

<EXIT Section>
 down(&rmutex);                  //reserve exit section - avoids race condition with readers
 readcount--;                       //indicate you're leaving
  if (readcount == 0)          //checks if you are last reader leaving
   up(&resource);              //if last, you must release the locked resource
 up(&rmutex);                  //release exit section for other readers
}

//WRITER
void writer() {
  <ENTRY Section>
  down(&wmutex);                  //reserve entry section for writers - avoids race conditions
  writecount++;                //report yourself as a writer entering
  if (writecount == 1)         //checks if you're first writer
   down(&readLock);               //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
  up(&wmutex);                  //release entry section

<CRITICAL Section>
 down(&resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
  //writing is performed
 up(&resource);                //release file

<EXIT Section>
  down(&wmutex);                  //reserve exit section
  writecount--;                //indicate you're leaving
  if (writecount == 0)         //checks if you're the last writer
   up(&readLock);               //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
  up(&wmutex);                  //release exit section
}
```

We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.

From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.

```source-c
int readCount;                  // init to 0; number of readers currently accessing resource

// all semaphores initialised to 1
Semaphore resourceAccess;       // controls access (read/write) to the resource
Semaphore readCountAccess;      // for syncing changes to shared variable readCount
Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

void writer()
{ 
    down(&serviceQueue);           // wait in line to be servicexs
    // <ENTER>
    down(&resourceAccess);         // request exclusive access to resource
    // </ENTER>
    up(&serviceQueue);           // let next in line be serviced

    // <WRITE>
    writeResource();            // writing is performed
    // </WRITE>

    // <EXIT>
    up(&resourceAccess);         // release resource access for next reader/writer
    // </EXIT>
}

void reader()
{ 
    down(&serviceQueue);           // wait in line to be serviced
    down(&readCountAccess);        // request exclusive access to readCount
    // <ENTER>
    if (readCount == 0)         // if there are no readers already reading:
        down(&resourceAccess);     // request resource access for readers (writers blocked)
    readCount++;                // update count of active readers
    // </ENTER>
    up(&serviceQueue);           // let next in line be serviced
    up(&readCountAccess);        // release access to readCount

    // <READ>
    readResource();             // reading is performed
    // </READ>

    down(&readCountAccess);        // request exclusive access to readCount
    // <EXIT>
    readCount--;                // update count of active readers
    if (readCount == 0)         // if there are no readers left:
        up(&resourceAccess);     // release resource access for all
    // </EXIT>
    up(&readCountAccess);        // release access to readCount
}

```

## 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 1. 管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>

### 2. FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div><br>

### 3. 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 4. 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

### 5. 共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

### 6. 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。


## 1 定义

1. 操作系统必须全方位地管理计算机系统中运行的程序。因此，操作系统为正在运行程序建立一个管理实体——进程
2. 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动
3. 进程是操作系统进行资源分配和调度的一个独立单位

### 一个进程包括五个部分

1. （OS管理运行程序的）数据结构P
2. （运行程序的）内存代码C
3. （运行程序的）内存数据D
4. （运行程序的）通用寄存器信息R
5. （OS控制程序执行的）程序状态字信息PSW

### 概念级的进程状态

1. 运行态：进程占有处理器运行
2. 就绪态：进程具备运行条件等待处理器运行
3. 等待态：进程由于等待资源、输入输出、信号等而不具备运行条件

### 三态模型

1. 运行态→等待态：等待资源、I/O、信号
2. 等待态→就绪态：资源满足、I/O结束、信号完成
3. 就绪态→运行态；处理器空闲时选择更高优先权进程抢占
4. 运行态→就绪态：运行时间片刻、有更高优先权进程

### 进程挂起

1. OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况
2. 运行资源不足表现为性能低和死锁两种情况
3. 解决办法（进程挂起）：剥夺某些进程的内存及其他资源，调入OS管理的对换区，不参加进程调度，待适当时候再调入内存、恢复资源、参与运行
4. 挂起态与等待态有着本质区别，后者占有已申请到的资源处于等待，前者没有任何资源

### 进程挂起的选择与恢复

1. 选择等待态、就绪态进程进入挂起等待态
2. 运行态进程可以挂起自己
3. 等待事件结束后，挂起就绪态
4. 一般选择挂起就绪态进程予以恢复

## 2 进程控制块（Process Control Block）

### 作用
* PCB是OS用于记录和刻画进程状态及环境信息的数据结构
* 借助PCB，OS可以全面管理进程物理实体，刻画进程的执行现状，控制进程的执行
### 划分
* 标识信息
    1. 进程标识
    2. 用于存放唯一标识该进程的信息
        1. 系统分配的标识号
        2. 系统分配的进程组标识号
        3. 用户定义的进程名
        4. 用户定义的进程组名

* 现场信息
    1. 用户可见寄存器内容
    2. 控制/状态寄存器内容
    3. 用户/核心栈指针
    4. 用于存放该进程运行时的处理器现场信息
        1. 用户可见寄存器内容：数据寄存器、地址寄存器
        2. 控制与状态寄存器内容：PC、IR、PSW
        3. 栈指针内容：核心栈与用户栈指针

* 控制信息：用于存放与管理、调度进程相关的信息

    1. 调度相关信息：状态、等待事件/原因、优先级
    2. 进程组成信息：代码/数据地址、外存映像地址
    3. 队列指引元：进程队列指针、父子兄弟进程指针
    4. 通信相关信息：消息队列、信号量、锁
    5. 进程特权信息：内存访问权限、处理器特权
    6. 处理器使用信息：占用的处理器、时间片、处理器使用事件/已执行总时间、记账信息
    7. 资源清单信息：正占用的资源、已使用的资源

## 3 模式切换和进程切换

1. 一些中断/异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程

### 处理流程：
1. （中断/异常触发）正向模式切换压入PSW/PC
2. 保存被中断进程的现场信息
3. 处理中断/异常
4. 恢复被中断进程的现场信息
5. （中断返回指令触发）逆向模式转换弹出PSW/PC

## 3.1 模式切换（处理器状态切换）

1. 进程切换必须在操作系统内核模式下完成，这就需要模式切换

### 切换：

1. 用户模式到内核模式：由中断/异常/系统调用，中断用户进程执行而触发
2. 内核模式到用户模式：OS执行中断返回指令将控制权交还用户进程而触发

### 基本工作任务

1. 中断装置完成正向模式切换，包括：
    1. 处理器模式转为内核模式
    2. 保存当前进程的PC/PSW值到核心栈
    3. 转向中断/异常/系统调用处理程序
2. 中断返回指令完成逆向模式转换，包括：
    1. 从待运行进程核心栈中弹出PSW/PC值
    2. 处理器模式转为用户模式

## 3.2 进程切换
### 定义
* 进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行
* 进程切换实质上就是被中断运行进程与待运行进程的上下文切换，处理过程：
    1. 保存被中断进程的上下文
    2. 转向进程调度
    3. 恢复待运行进程的上下文

### 工作过程

1. （中断/异常等触发）正向模式切换并压入PSW
2. 保存被中断进程的现场信息
3. 处理具体中断/异常
4. 把被中断进程的系统堆栈指针SP值保存到PCB
5. 调整被中断进程的PCB信息，如进程状态
6. 把被中断进程的PCB加入相关队列
7. 选择下一个占用CPU运行的进程
8. 修改被选中进程的PCB信息，如进程状态
9. 设置被选中进程的地址空间，恢复存储管理信息
10. 恢复被选中进程的SP值到处理器寄存器SP
11. 恢复被选中进程的现场信息进入处理器
12. （中断返回指令触发）逆向模式转换并弹出PSW/PC

### 发生时机：进程切换一定发生在中断/异常/系统调用处理过程中

1. 阻塞式系统调用、虚拟地址异常导致被中断进程进入等待态
2. 时间片中断、I/O中断后发现更高优先级进程导致被中断进程转入就绪态
3. 终止用系统调用、不能继续执行的异常导致被中断进程进入终止态

## 4 原语与进程控制原语

1. 进程控制过程中涉及对OS核心数据结构（进程表/PCB池/队列/资源表）的修改
2. 为防止与时间有关的错误，应使用原语
3. 原语是由于若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性
4. 原语的执行可以通过关中断实现
5. 进程控制使用的原语称为进程控制原语
6. 另一类常用原语是进程通信原语

## 5 进程的控制与管理

1. 进程创建：进程表加一项，申请PCB并初始化，生成标识，建立映像，分配资源，移入就绪队列
2. 进程撤销：从队列中移除，归还资源，撤销标识，回收PCB，移除进程表项
3. 进程阻塞：保存现场信息，修改PCB，移入等待队列，调度其他进程执行
4. 进程唤醒：等待队列中移除，修改PCB，移入就绪队列（该进程优先级高于运行进程触发抢占）
5. 进程挂起：修改状态并出入相关队列，收回内存等资源送至对换区
6. 进程激活：分配内存，修改状态并出入相关队列
7. 其他：如修改进程特权

## 6 队列管理模块

1. 队列管理模块是操作系统实现进程管理的核心模块
2. 操作系统建立多个进程队列，包括就绪队列和等待队列
3. 按需组织为先进先出队列与优先队列
4. 队列中的进程可以通过PCB中的队列指引元采用单/双指引元或索引连接
5. 出队与入队操作
6. 进程与资源调度围绕进程队列展开

## 7 关键的进程管理软件

### 系统调用/中断/异常处理程序
### 队列管理模块
### 进程控制程序
### 进程调度程序（独立进程居多）
### 进程通信程序（多个程序包）
### 终端登陆与作业控制程序、性能监控程序、审计程序等外围程序

## 8 进程上下文（Process context）

1. 进程的执行需要环境支持，包括CPU现场和Cache中的执行信息
2. OS中的进程物理实体和支持进程运行的环境合成进程上下文，包括以下：
    1. 用户级上下文：用户程序块/用户数据区/用户栈/用户共享内存
    2. 寄存器上下文：PSW/栈指针/通用寄存器
    3. 系统级上下文：PCB/内存区表/核心栈
3. 进程上下文刻画了进程的执行情况

## 9 进程映像（Process Image）
1. 某一时刻进程的内容及其执行状态集合
    1. 进程控制块：保存进程的标识信息、状态信息和控制信息
    2. 进程程序块：进程处理的数据空间，包括数据、处理函数的用户栈可修改的程序
    3. 核心栈：进程在内核模式下运行时使用的堆栈，中断或系统过程使用
2. 进程映像是内存级的物理实体，又称为进程的内存映像

## 10 线程
### 传统进程是单线程结构进程
#### 问题：

1. 进程切换开销大
2. 进程通信开销大
3. 限制了进程并发的粒度
4. 降低了并行计算的效率

#### 解决思路：

1. 分离两个功能，”独立分配资源“与”被调度分派执行“
2. 进程作为系统资源分配和保护的独立单位，不需要频繁地切换
3. 线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换
4. 线程的出现会减少进程并发执行所付出的时空开销，使得并发粒度更细、并发性更好

### 多线程环境下进程的概念
1. 在多线程环境中，进程是操作系统中进行保护和资源分配的独立单位，具有：
    1. 用来容纳进程映像的虚拟地址空间
    2. 对进程、文件和设备的存取保护机制

### 多线程环境下线程的概念

1. 线程是进程的一条执行路径，是调度的基本单位，同一个进程中的所有线程共享进程获得的主存空间和资源。它具有：
    1. 线程执行状态
    2. 受保护的线程上下文，当线程不运行时，用于存储线程信息
    3. 独立的程序指令计数器
    4. 执行堆栈
    5. 容纳局部变量的静态存储器

### 多线程环境下线程的状态与调度

1. 线程状态有运行、就绪和睡眠，无挂起
2. 与线程状态变化有关的线程操作有：
    1. 孵化、封锁、活化、剥夺、指派、结束
3. OS感知线程环境下：
    1. 处理器调度对象是线程
    2. 进程没有三状态（或者说只有挂起状态）
4. OS不感知线程环境下：
    1. 处理器调度对象仍是进程
    2. 用户空间中的用户调度程序调度线程

### 并发多线程程序设计的优点

1. 快速线程切换
2. 减少（系统）管理开销
3. （线程）通信易于实现
4. 并行程序提高
5. 节省内存空间

### 多线程技术的应用

1. 前台和后台工作
2. C/S应用模式
3. 加快执行速度
4. 设计用户接口

### 内核级线程（KLT，Kernel-Level Threads）

1. 线程管理的所有工作由OS内核来做
2. OS提供了一个应用程序设计接口API，供开发者使用KLT
3. OS直接调度KLT
4. KLT适用于解决物理并行性问题
5. 特点
    1. 进程中的一个线程被阻塞了，内核能调度同一进程的其他线程占用处理器运行
    2. 多处理器环境中，内核能同时调度同一进程中多个线程并行执行
    3. 内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率
    4. 应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大

### 用户级线程（ULT，User-Level Threads）
1. 用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境
2. 任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行
3. 线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在
4. ULT适用于解决逻辑并行性问题
5. 特点
    1. 所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能节省模式切换开销和内核的宝贵资源
    2. 允许进程按应用特定需要选择调度算法，甚至根据应用需要裁剪调度算法
    3. 能运行在任何OS上，内核在支持ULT方面不需要做任何工作
    4. 不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行
    5. 一个ULT的阻塞，将引起整个进程的阻塞

### Jacketing技术

1. 把阻塞式系统调用改造成非阻塞式的
2. 把线程陷入系统调用时，执行jacketing程序
3. 由jacketing程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程

### 多线程实现的混合式策略

1. 线程创建是完全在用户空间做的
2. 单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果
3. 特点
    1. 组合ULT/KLTs设施
    2. 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行
    3. 一个应用中的多个ULT被映射到一些（小于等于ULT数目）内核级线程上
    4. 程序员可以针对特定应用和机器调节KLT数目，以达到整体最佳结果
    5. 该方法将会结合纯粹ULT方法和KLT方法的优点，同时减少它们的缺点

### 线程混合式策略下的线程状态

1. KLT负责三态，系统调用负责
2. ULT负责三态，用户调度负责
3. 活跃态ULT代表绑定KLT的三态
4. 活跃态ULT运行时可激活用户调度
5. 非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT
