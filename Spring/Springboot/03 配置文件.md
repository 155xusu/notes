## 1 properties配置基础

### properties默认配置文件
用于配置容器端口名、数据库链接信息、日志级别。pom是项目编程的配置，properties是软件部署的配置。

移除特殊字符、全小写。在环境变量中通过小写转换与.替换_来映射配置文件中的内容，比如：环境变量SPRING_JPA_DATABASEPLATFORM=mysql的配置会产生与在配置文件中设置spring.jpa.databaseplatform=mysql一样的效果。

```
src/main/resources/application.properties
```

```
environments.dev.url=http://dev.bar.com
environments.dev.name=Developer Setup
environments.prod.url=http://foo.bar.com
environments.prod.name=My Cool App
```


### 列表类型
> 必须使用连续下标索引进行配置。


* properties中使用[]在定位列表类型
```
pring.my-example.url[0]=http://example.com
spring.my-example.url[1]=http://spring.io
```
* properties中使用,分割列表类型。

```
pring.my-example.url[0]=http://example.com
spring.my-example.url[1]=http://spring.io
```

* yaml中使用列表

```
spring:
  my-example:
    url:
      - http://example.com
      - http://spring.io

```
* yaml文件中使用,分割列表
```
spring:
  my-example:
    url: http://example.com, http://spring.io
```
### Map类型

Map类型在properties和yaml中的标准配置方式如下：

* properties格式：

```
spring.my-example.foo=bar
spring.my-example.hello=world
```
* yaml格式：
```
spring:
  my-example:
    foo: bar
    hello: world
```


### 使用随机数配置
`${random}`的配置方式主要有一下几种，读者可作为参考使用。

```
# 随机字符串
com.didispace.blog.value=${random.value}
# 随机int
com.didispace.blog.number=${random.int}
# 随机long
com.didispace.blog.bignumber=${random.long}
# 10以内的随机数
com.didispace.blog.test1=${random.int(10)}
# 10-20的随机数
com.didispace.blog.test2=${random.int[10,20]}
```


## 2 yaml配置文件
### yaml基本语法

*  key: value；kv之间有空格
*  大小写敏感
*  使用缩进表示层级关系
*  缩进不允许使用tab，只允许空格
*  缩进的空格数不重要，只要相同层级的元素左对齐即可
*  '#'表示注释
*  字符串无需加引号，如果要加，''与""表示字符串内容 会被 转义/不转义
```
environments:
    dev:
        url: http://dev.bar.com
        name: Developer Setup
    prod:
        url: http://foo.bar.com
        name: My Cool App
```

### yaml基本类型
* 字面量：单个的、不可再分的值。date、boolean、string、number、null
```
k: v
```
* 对象：键值对的集合。map、hash、set、object
```
行内写法：  k: {k1:v1,k2:v2,k3:v3}
#或
k: 
	k1: v1
  k2: v2
  k3: v3
```
* 数组：一组按次序排列的值。array、list、queue
```
行内写法：  k: [v1,v2,v3]
#或者
k:
 - v1
 - v2
 - v3
```

### yaml的实例
```
@Data
public class Person {
	
	private String userName;
	private Boolean boss;
	private Date birth;
	private Integer age;
	private Pet pet;
	private String[] interests;
	private List<String> animal;
	private Map<String, Object> score;
	private Set<Double> salarys;
	private Map<String, List<Pet>> allPets;
}

@Data
public class Pet {
	private String name;
	private Double weight;
}

```
对应的yaml配置

```
# yaml表示以上对象
person:
  userName: zhangsan
  boss: false
  birth: 2019/12/12 20:12:33
  age: 18
  pet: 
    name: tomcat
    weight: 23.4
  interests: [篮球,游泳]
  animal: 
    - jerry
    - mario
  score:
    english: 
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: {first: 128,second: 136}
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - {name: tom}
      - {name: jerry,weight: 47}
    health: [{name: mario,weight: 47}]
```


## 3 其他配置方式
### 系统环境变量

* 列表形式：由于环境变量中无法使用[和]符号，所以使用_来替代。任何由下划线包围的数字都会被认为是[]的数组形式。
```
MY_FOO_1_ = my.foo[1]
MY_FOO_1_BAR = my.foo[1].bar
MY_FOO_1_2_ = my.foo[1][2]
```
### 通过命令行配置
在启动java应用是，添加配置参数。系统属性的绑定也与文件属性的绑定类似，通过[]来标示，同样的，他也支持逗号分割的方式

```
java -jar xxx.jar --server.port=8888

-D"spring.my-example.url[0]=http://example.com"
-D"spring.my-example.url[1]=http://spring.io"


-Dspring.my-example.url=http://example.com,http://spring.io

```



## 4 多环境配置

### 配置方法
对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包。

在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应你的环境标识，比如：

* application-dev.properties：开发环境
* application-test.properties：测试环境
* application-prod.properties：生产环境

### 配置加载顺序

1. 命令行中传入的参数。
1. SPRING_APPLICATION_JSON中的属性。SPRING_APPLICATION_JSON是以JSON格式配置在系统环境变量中的内容。
1. java:comp/env中的JNDI属性。
1. Java的系统属性，可以通过System.getProperties()获得的内容。
1. 操作系统的环境变量
1. 通过random.*配置的随机属性
1. 位于当前应用jar包之外，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件
1. 位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件
1. 位于当前应用jar包之外的application.properties和YAML配置内容
1. 位于当前应用jar包之内的application.properties和YAML配置内容
1. 在@Configuration注解修改的类中，通过@PropertySource注解定义的属性
1. 应用默认属性，使用SpringApplication.setDefaultProperties定义的内容1. 

## 5 自定义配置文件/加载配置文件/属性绑定
### 读取规则

 将配置文件中的值引入到java程序中。

在Spring应用程序的environment中读取属性的时候，每个属性的唯一名称符合如下规则：

* 通过.分离各个元素
* 最后一个.将前缀与属性名称分开
* 必须是字母（a-z）和数字(0-9)
* 必须是小写字母
* 用连字符-来分隔单词
* 唯一允许的其他字符是[和]，用于List的索引
* 不能以数字开头

```
this.environment.containsProperty("spring.jpa.database-platform")
```

### 引入依赖

```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>


<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-configuration-processor</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### @Value
* 通过占位符的方式加载自定义的参数

```
@Component
public class Book {

    @Value("${book.name}")
    private String name;
    @Value("${book.author}")
    private String author;

    // 省略getter和setter
}
```
* @Value支持的表达式格式
```
#{...}
${...}
```


### @ConfigurationProperties 

假设在propertes配置中有这样一个配置：
```
com.didispace.foo=bar
```
我们为它创建对应的配置类：
```
@Data
@ConfigurationProperties(prefix = "com.didispace")
public class FooProperties {

    private String foo;

}
```
接下来，通过最新的Binder就可以这样来拿配置信息了：
```
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Application.class, args);

        Binder binder = Binder.get(context.getEnvironment());

        // 绑定简单配置
        FooProperties foo = binder.bind("com.didispace", Bindable.of(FooProperties.class)).get();
        System.out.println(foo.getFoo());
    }
}
```