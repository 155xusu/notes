\>递归的实现：

**[python]** [view
plain](http://blog.csdn.net/estom_yin/article/details/51892697)
[copy](http://blog.csdn.net/estom_yin/article/details/51892697)

1.  \<pre name="code" **class**="python"\>**def** p(n):

2.  **if** n ==1 **or** n == 0:

3.  **return** 1

\>递归的设计：

>   将问题分解成许多同构的问题，然后以相同的方式解决最终分解的小问题。

>   递归的要素：

>   递归执行的操作

>   递归的结束条件

>   递归的参数传递

\>实例一：兔子序列（菲波那切数列，在自然界一些动植物身上都有体现）

**[python]** [view
plain](http://blog.csdn.net/estom_yin/article/details/51892697)
[copy](http://blog.csdn.net/estom_yin/article/details/51892697)

1.  **def** fib(n):

2.  **if** n == 1 **or** n == 2:

3.  **return** 1

4.  **else**:

5.  **return** fib(n - 1) + fib(n - 2)

6.  **print** fib(20)

\>实例二：汉诺塔问题

**[python]** [view
plain](http://blog.csdn.net/estom_yin/article/details/51892697)
[copy](http://blog.csdn.net/estom_yin/article/details/51892697)

1.  **def** hanoi(n, A, B, C):

2.  **if** n == 1:

3.  **print** "move", n, "from", A, "to", C

4.  **else**:

5.  hanoi(n - 1, A, C, B)

6.  **print** 'move', n, 'from', A, 'to', C

7.  hanoi(n - 1, B, A, C)

8.  

9.  hanoi(10, 'left', 'Mid', 'Right')

\>实例三：停车问题

>   要求：在固定长度的马路上随机停车，根据车身长度以及随机性特点确定，马路长度与停车数量的关系

**[python]** [view
plain](http://blog.csdn.net/estom_yin/article/details/51892697)
[copy](http://blog.csdn.net/estom_yin/article/details/51892697)

1.  **import** random

2.  \#if the w big enough, lim parking to 3.7472 named Reni constance

3.  

4.  **def** parking(low, high):

5.  **if** high - low \< 1:

6.  **return** 0

7.  **else**:

8.  x = random.uniform(low, high - 1)

9.  **return** parking(low, x) + 1 + parking(x + 1, high)

10. **print** parking(0, 5)

\>递归的优劣

\>\>能使一个蕴含递归关系而且结构复杂的程序简洁精练，增强可读性

\>\>嵌套层次深，函数调用开销大，存在大量的重复计算

\>补充琐碎知识

>   random.uniform(low, high) 能产生从low到high的随机数
