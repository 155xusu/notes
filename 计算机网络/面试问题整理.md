## 1. 对网络模型的理解
> 五层网络模型、七层网络模型。各层的主要作用。各层的数据结构。各层运行的协议。


## 2. TCP可靠数据传输的实现机制
> 停止等待、回退N步、选择重传。
1. 校验和
2. 序号机制
3. 确认机制和超时重传。
4. 滑动窗口和流水线技术
5. 累计确认机制
6. 选择重传机制
## 3. TCP的三次握手四次挥手
> 报文段类型SYN、FIN。状态迁移。序号变化。


## 4. TCP的流量控制和拥塞控制
1. 慢启动
2. 拥塞避免
3. 快重传
4. 快回复

## 5 路由算法
1. 链路状态路由算法
2. 距离向量路由算法
3. 层次路由算法OSPF、BGP


## 6 为什么会出现粘包
主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。
“粘包”可发生在发送端也可发生在接收端：
1. 由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。
简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，
而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。
2. 接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。
当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。
解决办法
出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。
封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。
包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。
我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。

## 7. HTTP请求的过程
1. 域名解析
2. 三次握手
3. 浏览器HTTP请求、服务器HTTP响应
4. 浏览器得到HTML、JS代码。
5. 浏览器渲染页面，给用户。

### 具体过程

1. 域名解析
   1. DNS缓存（浏览器DNS缓存、操作系统DNS缓存）
   2. Host匹配
   3. 域名服务器递归解析（IP地址）
1. 封包过程与解包过程
   1. 应用层：HTML报文
   2. 传输层：TCP报文段。添加TCP报头。
   3. 网络层：IP数据报。分片。
   4. 链路层：帧
   5. 物理层：比特
2. 应用层
   1. 服务器的应用层负责处理请求的业务逻辑，返回结果。
   2. 客户端的应用层负责将得到的数据进行渲染和解析。
3. 传输层
   1. TCP三次握手
   2. 滑动窗口传输数据。可靠传输、拥塞控制
   3. TCP四次挥手
4.  网络层
    1. 路由。OSPF、BGP等协议，利用路由算法，确定下一跳的地址。路由表。
5.  链路层
    1.  转发。ARP地址解析协议。将IP地址转换为MAC地址。交换机表。控制碰撞
6.  物理层
    1. 比特。防止碰撞。


## 8 HTTP2.0

HTTP2.0和HTTP1.X相比的新特性

1. 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

2. 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

3. header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

3. 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。